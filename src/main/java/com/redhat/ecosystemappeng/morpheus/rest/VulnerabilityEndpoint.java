package com.redhat.ecosystemappeng.morpheus.rest;

import java.util.List;
import java.util.Objects;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.redhat.ecosystemappeng.morpheus.model.Pagination;
import com.redhat.ecosystemappeng.morpheus.model.SortField;
import com.redhat.ecosystemappeng.morpheus.model.UserComments;
import com.redhat.ecosystemappeng.morpheus.model.Vulnerability;
import com.redhat.ecosystemappeng.morpheus.service.VulnerabilityRepositoryService;

import jakarta.inject.Inject;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.DefaultValue;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.NotFoundException;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.enums.SchemaType;
import org.eclipse.microprofile.openapi.annotations.media.Content;
import org.eclipse.microprofile.openapi.annotations.media.Schema;
import org.eclipse.microprofile.openapi.annotations.parameters.Parameter;
import org.eclipse.microprofile.openapi.annotations.parameters.RequestBody;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponse;
import org.eclipse.microprofile.openapi.annotations.responses.APIResponses;
import org.eclipse.microprofile.openapi.annotations.security.SecurityRequirement;

@SecurityRequirement(name = "jwt")
@Path("/vulnerabilities")
@Consumes(MediaType.APPLICATION_JSON)
public class VulnerabilityEndpoint {

  @Inject
  VulnerabilityRepositoryService repository;

  @Inject
  ObjectMapper objectMapper;

  @Inject
  UserComments userComments;

  @GET
  @Path("/{vuln_id}/comments")
  @Produces(MediaType.TEXT_PLAIN)
  @Operation(
    summary = "Get vulnerability comments", 
    description = "Retrieves user comments for a specific vulnerability by ID")
  @APIResponses({
    @APIResponse(
      responseCode = "200", 
      description = "Comments retrieved successfully",
      content = @Content(
        mediaType = MediaType.TEXT_PLAIN,
        schema = @Schema(type = SchemaType.STRING),
        example = "CVE-2023-12345"
      )
    ),
    @APIResponse(
      responseCode = "404", 
      description = "Vulnerability not found"
    ),
    @APIResponse(
      responseCode = "500", 
      description = "Internal server error"
    )
  })
  public String getComments(
    @Parameter(
      description = "Vulnerability ID to get comments", 
      required = true
    )
    @PathParam("vuln_id") String id) {
    return get(id).comments();
  }

  @PUT
  @Path("/{vuln_id}")
  @Operation(
    summary = "Update vulnerability", 
    description = "Updates vulnerability information by ID")
  @APIResponses({
    @APIResponse(
      responseCode = "200", 
      description = "Vulnerability updated successfully"
    ),
    @APIResponse(
      responseCode = "400", 
      description = "Invalid vulnerability data"
    ),
    @APIResponse(
      responseCode = "500", 
      description = "Internal server error"
    )
  })
  public Response set(
    @Parameter(
      description = "Vulnerability ID to update", 
      required = true
    )
    @PathParam("vuln_id") String id, 
    @RequestBody(
      description = "Vulnerability data to update",
      required = true,
      content = @Content(schema = @Schema(implementation = Vulnerability.class))
    )
    Vulnerability vulnerability) {
    repository.persistOrUpdate(vulnerability);
    return Response.ok().build();
  }

  @GET
  @Operation(
    summary = "List vulnerabilities", 
    description = "Retrieves a paginated list of vulnerabilities with optional sorting")
  @APIResponses({
    @APIResponse(
      responseCode = "200", 
      description = "Vulnerabilities retrieved successfully",
      content = @Content(
        mediaType = MediaType.APPLICATION_JSON,
        schema = @Schema(type = SchemaType.ARRAY, implementation = Vulnerability.class)
      )
    ), 
    @APIResponse(
      responseCode = "500", 
      description = "Internal server error"
    )
  })
  public Response list(
      @Parameter(
        description = "Sort criteria in format 'field:direction' (e.g., '_id:ASC')"
      )
      @QueryParam("sortBy") @DefaultValue("_id:ASC") List<String> sortBy,
      @Parameter(
        description = "Page number (0-based)"
      )
      @QueryParam("page") @DefaultValue("0") Integer page,
      @Parameter(
        description = "Number of items per page"
      )
      @QueryParam("pageSize") @DefaultValue("1000") Integer pageSize) {

    var sort = SortField.fromSortBy(sortBy);
    var result = repository.find(sort, new Pagination(page, pageSize));
    return Response.ok(result.results)
        .header("X-Total-Pages", result.totalPages)
        .header("X-Total-Elements", result.totalElements)
        .build();
  }

  @DELETE
  @Path("/{vuln_id}")
  @Operation(
    summary = "Delete vulnerability", 
    description = "Deletes a specific vulnerability by ID")
  @APIResponses({
    @APIResponse(
      responseCode = "200", 
      description = "Vulnerability deleted successfully"
    ),
    @APIResponse(
      responseCode = "500", 
      description = "Internal server error"
    )
  })
  public Response delete(
    @Parameter(
      description = "Vulnerability ID to delete", 
      required = true
    )
    @PathParam("vuln_id") String id) {
    repository.delete("_id", id);
    return Response.ok().build();
  }

  @GET
  @Path("/{vuln_id}")
  @Operation(
    summary = "Get vulnerability", 
    description = "Retrieves detailed information for a specific vulnerability by ID")
  @APIResponses({
    @APIResponse(
      responseCode = "200", 
      description = "Vulnerability retrieved successfully",
      content = @Content(
        mediaType = MediaType.APPLICATION_JSON,
        schema = @Schema(implementation = Vulnerability.class)
      )
    ),
    @APIResponse(
      responseCode = "404", 
      description = "Vulnerability not found"
    ),
    @APIResponse(
      responseCode = "500", 
      description = "Internal server error"
    )
  })
  public Vulnerability get(
    @Parameter(
      description = "Vulnerability ID to get", 
      required = true
    )
    @PathParam("vuln_id") String id) {
    var vuln = repository.findById(id);
    if (Objects.isNull(vuln)) {
      throw new NotFoundException("No description found for vulnerability with id: " + id);
    }
    return vuln;
  }

  @GET
  @Path("/generate-comments-template")
  @Operation(
    summary = "Generate user comments template", 
    description = "Generates a template structure for user comments on vulnerabilities")
  @APIResponses({
    @APIResponse(
      responseCode = "200", 
      description = "Comments template generated successfully",
      content = @Content(
        mediaType = MediaType.APPLICATION_JSON,
        schema = @Schema(implementation = UserComments.class)
      )
    ),
    @APIResponse(
      responseCode = "500", 
      description = "Internal server error"
    )
  })
  public Response generateUserCommentsTemplate() throws JsonProcessingException {
    return Response.ok(objectMapper.writeValueAsString(userComments)).build();
  }
}
